<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Single File Clipboard Manager</title>
    <style>
      :root {
        --bg: #f8fafc;
        --card: #ffffffee;
        --text: #0f172a;
        --muted: #475569;
        --muted-2: #64748b;
        --border: #e2e8f0;
        --primary: #2563eb;
        --primary-700: #1d4ed8;
        --warning: #f59e0b;
        --danger: #ef4444;
        --success: #16a34a;

        --radius: 14px;
        --radius-sm: 10px;
        --radius-xs: 8px;

        --shadow-1: 0 8px 24px rgba(2, 6, 23, 0.08);
        --shadow-2: 0 2px 10px rgba(2, 6, 23, 0.06);
        --shadow-focus: 0 0 0 3px rgba(37, 99, 235, 0.15);

        --gradient-hero: linear-gradient(
          135deg,
          #e0f2fe 0%,
          #f5f3ff 35%,
          #fef9c3 70%,
          #ffe4e6 100%
        );
        --gradient-card: linear-gradient(180deg, #ffffff80, #ffffffcc);
        --chip-bg: #eef2ff;
        --chip-text: #3730a3;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        padding: 0;
        margin: 0;
        background:
          radial-gradient(1200px 600px at -10% -10%, #e0f2fe 0, transparent 60%),
          radial-gradient(1000px 500px at 110% 0%, #f5f3ff 0, transparent 60%),
          radial-gradient(1000px 500px at 50% 110%, #ffe4e6 0, transparent 60%),
          var(--bg);
        color: var(--text);
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI,
          Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji",
          "Segoe UI Symbol";
        line-height: 1.55;
      }

      .page {
        max-width: 1100px;
        margin: 32px auto 80px;
        padding: 0 18px;
      }

      .hero {
        background: var(--gradient-hero);
        border: 1px solid var(--border);
        border-radius: 24px;
        padding: 28px 24px;
        box-shadow: var(--shadow-1);
        position: relative;
        overflow: hidden;
      }

      .hero::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(
          700px 280px at 80% -10%,
          rgba(255, 255, 255, 0.6),
          transparent 60%
        );
        pointer-events: none;
      }

      h1 {
        margin: 0 0 6px 0;
        font-size: 28px;
        letter-spacing: -0.01em;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 14px;
      }

      .container {
        background: var(--gradient-card);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 18px;
        margin-top: 18px;
        box-shadow: var(--shadow-2);
        backdrop-filter: blur(6px);
      }

      h2 {
        margin: 0 0 14px 0;
        font-size: 18px;
        color: var(--text);
        letter-spacing: 0.2px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      label {
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 6px;
        display: inline-block;
        font-size: 13px;
      }

      input[type="text"],
      textarea,
      select {
        width: 100%;
        padding: 12px 14px;
        border: 1px solid var(--border);
        border-radius: var(--radius-xs);
        background: #fff;
        color: var(--text);
        outline: none;
        transition: box-shadow 0.2s ease, border-color 0.2s ease;
        font-size: 14px;
      }

      input[type="text"]:focus,
      textarea:focus,
      select:focus {
        border-color: var(--primary);
        box-shadow: var(--shadow-focus);
      }

      textarea {
        min-height: 90px;
        resize: vertical;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid transparent;
        cursor: pointer;
        background: var(--primary);
        color: #fff;
        font-weight: 600;
        font-size: 14px;
        transition: transform 0.06s ease, filter 0.15s ease, box-shadow 0.15s;
        box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
        will-change: transform;
      }

      .btn:hover {
        filter: brightness(1.04);
        transform: translateY(-1px);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn.secondary {
        background: #fff;
        border-color: var(--border);
        color: var(--text);
        box-shadow: none;
      }

      .btn.danger {
        background: var(--danger);
        box-shadow: 0 6px 16px rgba(239, 68, 68, 0.25);
      }

      .btn.ghost {
        background: transparent;
        border-color: var(--border);
        color: var(--muted-2);
        box-shadow: none;
      }

      .btn:disabled {
        background: #cbd5e1 !important;
        color: #f8fafc !important;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }

      .btn + .btn {
        margin-left: 8px;
      }

      .row {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
      }

      .status {
        margin-top: 10px;
        font-style: normal;
        color: var(--muted-2);
        min-height: 1.2em;
        font-size: 13px;
      }

      .status.error {
        color: var(--danger);
        font-weight: 700;
      }

      .hidden {
        display: none !important;
      }

      /* Paste area */
      #pasteTarget {
        border-radius: var(--radius);
        border: 1px dashed #c7d2fe;
        min-height: 180px;
        padding: 16px;
        margin-top: 10px;
        background: #f8fafc;
        white-space: normal;
        word-wrap: break-word;
        overflow-y: auto;
        transition: box-shadow 0.15s ease, border-color 0.2s ease;
      }

      #pasteTarget:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: var(--shadow-focus);
      }

      #pasteTarget img {
        max-width: 100%;
        height: auto;
        display: block;
        margin-top: 10px;
        border-radius: var(--radius-xs);
        border: 1px solid var(--border);
      }

      #pasteTarget pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        background-color: #f1f5f9;
        padding: 10px;
        border: 1px solid var(--border);
        border-radius: var(--radius-xs);
        margin-top: 6px;
        max-height: 320px;
        overflow-y: auto;
      }

      #pasteTarget .html-toggle-container {
        margin: 8px 0 6px 0;
        font-size: 13px;
        color: var(--muted-2);
      }

      #pasteTarget .html-toggle-container label {
        font-weight: 500;
        margin-left: 6px;
      }

      /* Chips for detected types */
      .chips {
        display: flex;
        gap: 6px;
        margin: 8px 0 10px;
        flex-wrap: wrap;
      }
      .chip {
        background: var(--chip-bg);
        color: var(--chip-text);
        border: 1px solid #e0e7ff;
        padding: 2px 10px;
        border-radius: 999px;
        font-size: 12px;
        opacity: 0;
        transform: translateY(6px) scale(0.98);
        animation: chipIn 220ms
          cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      }
      @keyframes chipIn {
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      /* Mime entry */
      .mime-entry {
        border: 1px solid var(--border);
        padding: 14px;
        margin-bottom: 12px;
        background: #ffffff;
        border-radius: var(--radius-sm);
        position: relative;
        box-shadow: var(--shadow-2);
      }

      .mime-entry .remove-mime-button {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 6px 10px;
        font-size: 12px;
        background-color: #fff7ed;
        color: #92400e;
        border: 1px solid #fed7aa;
        border-radius: 10px;
        cursor: pointer;
        transition: filter 0.15s ease;
      }

      .mime-entry .remove-mime-button:hover {
        filter: brightness(0.97);
      }

      .mime-entry .image-preview {
        max-width: 140px;
        max-height: 100px;
        display: block;
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: var(--radius-xs);
      }

      .mime-entry .image-preview-note {
        font-size: 12px;
        font-style: italic;
        color: var(--muted-2);
        margin: 6px 0 4px;
      }

      /* Saved items list */
      #savedItemsList .item {
        border: 1px solid var(--border);
        padding: 14px;
        margin-bottom: 12px;
        background: #fff;
        border-radius: var(--radius-sm);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        box-shadow: var(--shadow-2);
        transition: transform 140ms ease, box-shadow 140ms ease, opacity 200ms,
          max-height 240ms ease;
        opacity: 0;
        transform: translateY(6px);
      }
      #savedItemsList .item.enter {
        opacity: 1;
        transform: translateY(0);
      }
      #savedItemsList .item.exit {
        opacity: 0;
        max-height: 0;
        margin: 0;
        padding-top: 0;
        padding-bottom: 0;
        overflow: hidden;
      }

      #savedItemsList .item-content {
        flex-grow: 1;
        margin-right: 10px;
        word-break: break-word;
        color: var(--text);
        font-size: 14px;
      }

      #savedItemsList .mime-chip {
        display: inline-block;
        background: var(--chip-bg);
        color: var(--chip-text);
        padding: 2px 8px;
        border-radius: 999px;
        margin-left: 6px;
        font-size: 12px;
        border: 1px solid #e0e7ff;
      }

      #savedItemsList .item-buttons .btn {
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 10px;
      }

      /* Collapsible generator header */
      .collapse-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        cursor: pointer;
        user-select: none;
      }
      .collapse-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .chevron {
        width: 18px;
        height: 18px;
        border: 2px solid var(--muted-2);
        border-left: 0;
        border-top: 0;
        transform: rotate(-45deg);
        transition: transform 180ms ease;
        border-radius: 2px;
      }
      .collapsed .chevron {
        transform: rotate(135deg);
      }
      .generator-summary {
        color: var(--muted-2);
        font-size: 13px;
      }

      .collapse-body {
        overflow: hidden;
        transition: grid-template-rows 200ms ease, opacity 200ms ease;
        display: grid;
        grid-template-rows: 1fr;
        opacity: 1;
      }
      .collapsed .collapse-body {
        grid-template-rows: 0fr;
        opacity: 0.95;
      }
      .collapse-inner {
        min-height: 0;
      }

      /* Toasts */
      .toasts {
        position: fixed;
        bottom: 18px;
        right: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 9999;
      }
      .toast {
        background: #ffffff;
        border: 1px solid var(--border);
        border-left: 4px solid var(--primary);
        padding: 12px 14px;
        border-radius: 12px;
        box-shadow: var(--shadow-1);
        color: var(--text);
        min-width: 240px;
        max-width: 340px;
        display: flex;
        align-items: flex-start;
        gap: 10px;
        opacity: 0;
        transform: translateY(8px);
        transition: opacity 160ms ease, transform 160ms ease;
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }
      .toast.success {
        border-left-color: var(--success);
      }
      .toast.error {
        border-left-color: var(--danger);
      }
      .toast .toast-close {
        margin-left: auto;
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--muted-2);
        font-weight: 700;
      }

      /* Copy success checkmark animation */
      .btn.copy.success {
        background: var(--success) !important;
        box-shadow: 0 6px 16px rgba(22, 163, 74, 0.25);
      }
      .btn.copy .check {
        width: 16px;
        height: 16px;
        border: 2px solid #fff;
        border-left: 0;
        border-top: 0;
        transform: rotate(45deg) scale(0.6);
        opacity: 0;
        transition: transform 160ms ease, opacity 160ms ease;
      }
      .btn.copy.success .check {
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }

      /* Reduced motion support */
      @media (prefers-reduced-motion: reduce) {
        * {
          animation-duration: 1ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 1ms !important;
          scroll-behavior: auto !important;
        }
      }

      @media (max-width: 640px) {
        .btn + .btn {
          margin-left: 6px;
        }
        .hero {
          padding: 20px 16px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="hero">
        <h1>Clipboard Manager</h1>
        <p class="subtitle">
          Save, edit, and copy rich clipboard items (Text, HTML, Images) with a
          modern, delightful UI.
        </p>
      </div>

      <div class="container">
        <h2>Clipboard Watcher (Paste Area)</h2>
        <p class="subtitle">
          Click in the box and press Ctrl+V (or Cmd+V) to preview clipboard
          content.
        </p>
        <div
          id="pasteTarget"
          aria-label="Paste clipboard content here"
          tabindex="0"
        ></div>
        <div class="chips" id="detectedChips" aria-live="polite"></div>
        <div class="row watcher-options">
          <button id="clearPasteAreaButton" class="btn ghost">Clear</button>
          <button id="editPastedContentButton" class="btn" disabled>
            Edit This Content
          </button>
        </div>
        <p class="status" id="watcherStatus"></p>
      </div>

      <div class="container" id="generatorSection">
        <div class="collapse-header" id="generatorHeader">
          <div class="collapse-left">
            <div class="chevron" aria-hidden="true"></div>
            <h2 style="margin: 0">Generator: Define/Edit Clipboard Item</h2>
          </div>
          <div class="generator-summary" id="generatorSummary">
            Collapsed • No draft
          </div>
        </div>
        <div class="collapse-body" id="generatorCollapse">
          <div class="collapse-inner">
            <input type="hidden" id="editingItemId" value="" />
            <div class="field" style="margin-top: 14px">
              <label for="itemDescription">Item Description</label>
              <input
                type="text"
                id="itemDescription"
                placeholder="e.g., My Email Signature"
              />
            </div>

            <div id="mimeEntriesContainer"></div>

            <div class="row">
              <button id="addMimeButton" class="btn secondary">
                + Add Content Type
              </button>
              <button id="saveItemButton" class="btn" disabled>
                Save Clipboard Item
              </button>
              <button
                id="cancelEditButton"
                class="btn ghost hidden"
                style="border-color: transparent"
              >
                Cancel Edit
              </button>
            </div>
            <p class="status" id="generatorStatus"></p>
          </div>
        </div>
      </div>

      <div class="container">
        <h2>Saved Items</h2>
        <div id="savedItemsList">
          <p class="subtitle">Loading items...</p>
        </div>
      </div>
    </div>

    <div class="toasts" aria-live="polite" aria-atomic="true" id="toasts"></div>

    <template id="mimeEntryTemplate">
      <div class="mime-entry">
        <button
          class="remove-mime-button"
          title="Remove this content type"
        >
          Remove
        </button>
        <div class="field">
          <label>Content Type</label>
          <select class="mime-type-select">
            <option value="text/plain">Text (text/plain)</option>
            <option value="text/html">HTML (text/html)</option>
            <option value="image/png">PNG Image (image/png)</option>
          </select>
        </div>
        <div class="content-input">
          <div class="field">
            <label>Content</label>
            <textarea
              class="mime-content-text"
              placeholder="Enter text or HTML here..."
            ></textarea>
            <input
              type="file"
              class="mime-content-file"
              accept="image/png"
              style="display: none"
            />
            <div class="image-preview-container hidden">
              <p class="image-preview-note">
                Current image (choose file to replace):
              </p>
              <img
                src=""
                alt="Image Preview"
                class="image-preview"
              />
            </div>
          </div>
        </div>
      </div>
    </template>

    <script>
      const LOCAL_STORAGE_KEY = "clipboardManagerItems";
      const PREFS_KEY = "clipboardManagerPrefs";

      let currentMimeEntries = [];
      let savedClipboardItems = [];
      let mimeEntryCounter = 0;
      let editingItemId = null;
      let currentPastedData = null;

      const itemDescriptionInput = document.getElementById("itemDescription");
      const mimeEntriesContainer = document.getElementById(
        "mimeEntriesContainer"
      );
      const addMimeButton = document.getElementById("addMimeButton");
      const saveItemButton = document.getElementById("saveItemButton");
      const cancelEditButton = document.getElementById("cancelEditButton");
      const generatorStatus = document.getElementById("generatorStatus");
      const savedItemsList = document.getElementById("savedItemsList");
      const pasteTarget = document.getElementById("pasteTarget");
      const clearPasteAreaButton = document.getElementById(
        "clearPasteAreaButton"
      );
      const editPastedContentButton = document.getElementById(
        "editPastedContentButton"
      );
      const watcherStatus = document.getElementById("watcherStatus");
      const mimeEntryTemplate = document.getElementById("mimeEntryTemplate");
      const editingItemIdInput = document.getElementById("editingItemId");
      const generatorSection = document.getElementById("generatorSection");
      const generatorHeader = document.getElementById("generatorHeader");
      const generatorCollapse = document.getElementById("generatorCollapse");
      const generatorSummary = document.getElementById("generatorSummary");
      const detectedChips = document.getElementById("detectedChips");
      const toasts = document.getElementById("toasts");

      function getPrefs() {
        try {
          return (
            JSON.parse(localStorage.getItem(PREFS_KEY)) || {
              generatorCollapsed: true,
            }
          );
        } catch {
          return { generatorCollapsed: true };
        }
      }
      function setPrefs(next) {
        const prev = getPrefs();
        localStorage.setItem(PREFS_KEY, JSON.stringify({ ...prev, ...next }));
      }

      function setGeneratorCollapsed(collapsed) {
        generatorSection.classList.toggle("collapsed", collapsed);
        setPrefs({ generatorCollapsed: collapsed });
        updateGeneratorSummary();
      }

      function toggleGenerator() {
        const collapsed = generatorSection.classList.contains("collapsed");
        setGeneratorCollapsed(!collapsed);
      }

      function updateGeneratorSummary() {
        const collapsed = generatorSection.classList.contains("collapsed");
        const hasDraft =
          (itemDescriptionInput.value?.trim()?.length || 0) > 0 ||
          currentMimeEntries.some(
            (e) =>
              (e.type === "image/png" && (e.file || e.preservedBlob)) ||
              (e.type !== "image/png" && e.content?.trim())
          );
        const entrySummary = currentMimeEntries
          .map((e) =>
            e.type === "image/png" ? "Image" : e.type.split("/")[1] || e.type
          )
          .join(" + ");
        const draftText = hasDraft
          ? `Draft: ${entrySummary || "No content"}`
          : "No draft";
        generatorSummary.textContent = `${collapsed ? "Collapsed" : "Expanded"} • ${draftText}`;
      }

      function toast(message, type = "info", duration = 2500) {
        const t = document.createElement("div");
        t.className = `toast ${type}`;
        const span = document.createElement("span");
        span.textContent = message;
        const close = document.createElement("button");
        close.className = "toast-close";
        close.setAttribute("aria-label", "Close");
        close.textContent = "×";
        close.onclick = () => removeToast(t);
        t.appendChild(span);
        t.appendChild(close);
        toasts.appendChild(t);
        requestAnimationFrame(() => t.classList.add("show"));
        const timer = setTimeout(() => removeToast(t), duration);
        t.addEventListener("mouseenter", () => clearTimeout(timer), {
          once: true,
        });
        function removeToast(el) {
          if (!el) return;
          el.classList.remove("show");
          setTimeout(() => el.remove(), 180);
        }
      }

      function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      async function base64ToBlob(base64, type = "application/octet-stream") {
        try {
          const response = await fetch(base64);
          if (!response.ok) {
            throw new Error(
              `Failed to fetch base64 data: ${response.statusText}`
            );
          }
          return await response.blob();
        } catch (error) {
          console.error("Error converting base64 to Blob:", error);
          throw error;
        }
      }

      async function saveItemsToLocalStorage() {
        try {
          const serializableItems = [];
          for (const item of savedClipboardItems) {
            const serializableEntries = [];
            for (const entry of item.entries) {
              if (entry.type.startsWith("image/") && entry.data instanceof Blob) {
                const base64Data = await blobToBase64(entry.data);
                serializableEntries.push({
                  type: entry.type,
                  data: base64Data,
                });
              } else {
                serializableEntries.push({
                  type: entry.type,
                  data: entry.data,
                });
              }
            }
            serializableItems.push({
              id: item.id,
              description: item.description,
              entries: serializableEntries,
              updatedAt: Date.now(),
            });
          }
          localStorage.setItem(
            LOCAL_STORAGE_KEY,
            JSON.stringify(serializableItems)
          );
        } catch (error) {
          console.error("Failed to save items to localStorage:", error);
          setGeneratorStatus(
            "Error saving items locally. Data might be too large.",
            true
          );
          toast(
            "Error saving items locally. Data might be too large.",
            "error"
          );
        }
      }

      async function loadItemsFromLocalStorage() {
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!storedData) {
          savedClipboardItems = [];
          renderSavedItems();
          return;
        }

        try {
          const parsedItems = JSON.parse(storedData);
          const loadedItems = [];
          for (const item of parsedItems) {
            const deserializedEntries = [];
            for (const entry of item.entries) {
              if (
                entry.type.startsWith("image/") &&
                typeof entry.data === "string" &&
                entry.data.startsWith("data:image")
              ) {
                try {
                  const blobData = await base64ToBlob(entry.data, entry.type);
                  deserializedEntries.push({
                    type: entry.type,
                    data: blobData,
                  });
                } catch (conversionError) {
                  console.error(
                    `Failed to convert Base64 to Blob for item ${item.id}, entry type ${entry.type}:`,
                    conversionError
                  );
                  continue;
                }
              } else if (typeof entry.data === "string") {
                deserializedEntries.push({ type: entry.type, data: entry.data });
              }
            }

            loadedItems.push({
              id: item.id,
              description: item.description,
              entries: deserializedEntries,
              updatedAt: item.updatedAt || Date.now(),
            });
          }
          savedClipboardItems = loadedItems;
        } catch (error) {
          console.error("Failed to load or parse items from localStorage:", error);
          savedClipboardItems = [];
          setGeneratorStatus(
            "Error loading items from local storage. Data might be corrupted.",
            true
          );
          toast(
            "Error loading items from local storage. Data might be corrupted.",
            "error"
          );
        } finally {
          renderSavedItems();
        }
      }

      function updateSaveButtonState() {
        const description = itemDescriptionInput.value.trim();

        const hasValidEntries = currentMimeEntries.some(
          (entry) =>
            (entry.type !== "image/png" && entry.content) ||
            (entry.type === "image/png" && (entry.file || entry.preservedBlob))
        );
        saveItemButton.disabled = !(description && hasValidEntries);
        updateGeneratorSummary();
      }

      function addMimeEntry(initialData = null) {
        mimeEntryCounter++;
        const templateClone = mimeEntryTemplate.content.cloneNode(true);
        const mimeEntryDiv = templateClone.querySelector(".mime-entry");
        mimeEntryDiv.dataset.id = mimeEntryCounter;

        const select = mimeEntryDiv.querySelector(".mime-type-select");
        const textInput = mimeEntryDiv.querySelector(".mime-content-text");
        const fileInput = mimeEntryDiv.querySelector(".mime-content-file");
        const removeButton = mimeEntryDiv.querySelector(".remove-mime-button");
        const imagePreviewContainer = mimeEntryDiv.querySelector(
          ".image-preview-container"
        );
        const imagePreview = mimeEntryDiv.querySelector(".image-preview");

        const entryData = {
          id: mimeEntryCounter,
          type: initialData?.type || "text/plain",
          content:
            (initialData?.type !== "image/png" && initialData?.data) || "",
          file: null,
          preservedBlob:
            initialData?.type === "image/png" &&
            initialData?.data instanceof Blob
              ? initialData.data
              : null,
          element: mimeEntryDiv,
        };
        currentMimeEntries.push(entryData);

        select.value = entryData.type;
        textInput.value = entryData.content;

        const isImage = entryData.type === "image/png";
        textInput.style.display = isImage ? "none" : "block";
        fileInput.style.display = isImage ? "block" : "none";
        imagePreviewContainer.classList.toggle(
          "hidden",
          !isImage || !entryData.preservedBlob
        );

        if (isImage && entryData.preservedBlob) {
          try {
            const objectURL = URL.createObjectURL(entryData.preservedBlob);
            imagePreview.src = objectURL;
            entryData.previewUrl = objectURL;
          } catch (e) {
            console.error("Error creating object URL for preview:", e);
            imagePreviewContainer.classList.add("hidden");
          }
        }

        select.addEventListener("change", (e) => {
          if (entryData.previewUrl) {
            URL.revokeObjectURL(entryData.previewUrl);
            entryData.previewUrl = null;
          }

          entryData.type = e.target.value;
          const isNowImage = entryData.type === "image/png";
          textInput.style.display = isNowImage ? "none" : "block";
          fileInput.style.display = isNowImage ? "block" : "none";
          imagePreviewContainer.classList.add("hidden");

          if (isNowImage) {
            entryData.content = "";
            textInput.value = "";
            entryData.preservedBlob = null;
          } else {
            entryData.file = null;
            fileInput.value = null;
            entryData.preservedBlob = null;
          }
          updateSaveButtonState();
        });

        textInput.addEventListener("input", (e) => {
          entryData.content = e.target.value;
          updateSaveButtonState();
        });

        fileInput.addEventListener("change", (e) => {
          if (entryData.previewUrl) {
            URL.revokeObjectURL(entryData.previewUrl);
            entryData.previewUrl = null;
          }

          if (e.target.files && e.target.files[0]) {
            entryData.file = e.target.files[0];
            entryData.preservedBlob = null;

            try {
              entryData.previewUrl = URL.createObjectURL(entryData.file);
              imagePreview.src = entryData.previewUrl;
              imagePreviewContainer.classList.remove("hidden");
            } catch (err) {
              console.error("Error creating object URL for new file preview:", err);
              imagePreviewContainer.classList.add("hidden");
            }
          } else {
            entryData.file = null;
            imagePreviewContainer.classList.add("hidden");
          }
          updateSaveButtonState();
        });

        removeButton.addEventListener("click", () => {
          if (entryData.previewUrl) {
            URL.revokeObjectURL(entryData.previewUrl);
          }
          currentMimeEntries = currentMimeEntries.filter(
            (entry) => entry.id !== entryData.id
          );
          mimeEntryDiv.remove();
          updateSaveButtonState();
        });

        mimeEntriesContainer.appendChild(mimeEntryDiv);
        updateSaveButtonState();
      }

      async function saveOrUpdateClipboardItem() {
        const description = itemDescriptionInput.value.trim();
        if (!description || currentMimeEntries.length === 0) {
          setGeneratorStatus(
            "Please provide a description and at least one content type.",
            true
          );
          toast(
            "Please provide a description and at least one content type.",
            "error"
          );
          return;
        }

        const newItemData = {
          id:
            editingItemId && editingItemId !== -1 ? editingItemId : Date.now(),
          description: description,
          entries: [],
        };

        const processingPromises = currentMimeEntries.map(async (entry) => {
          if (entry.type === "image/png") {
            if (entry.file) {
              newItemData.entries.push({ type: entry.type, data: entry.file });
            } else if (entry.preservedBlob) {
              newItemData.entries.push({
                type: entry.type,
                data: entry.preservedBlob,
              });
            }
          } else if (entry.type !== "image/png" && entry.content.trim()) {
            newItemData.entries.push({ type: entry.type, data: entry.content });
          }
        });

        try {
          await Promise.all(processingPromises);

          if (newItemData.entries.length === 0) {
            setGeneratorStatus("No valid content found in the entries.", true);
            toast("No valid content found in the entries.", "error");
            return;
          }

          if (editingItemId && editingItemId !== -1) {
            const index = savedClipboardItems.findIndex(
              (item) => item.id === editingItemId
            );
            if (index !== -1) {
              savedClipboardItems[index] = newItemData;
              setGeneratorStatus(
                `Item "${description}" updated successfully.`,
                false
              );
              toast(`Updated "${description}".`, "success");
            } else {
              savedClipboardItems.push(newItemData);
              setGeneratorStatus(
                `Warning: Original item not found. Saved as new item "${description}".`,
                false
              );
              toast(
                `Original not found. Saved as new "${description}".`,
                "success"
              );
            }
          } else {
            savedClipboardItems.push(newItemData);
            setGeneratorStatus(`Item "${description}" saved successfully.`, false);
            toast(`Saved "${description}".`, "success");
          }

          await saveItemsToLocalStorage();
          renderSavedItems();
          resetGeneratorForm();
          setGeneratorCollapsed(true);
        } catch (error) {
          console.error("Error processing or saving item data:", error);
          setGeneratorStatus(`Error saving item: ${error.message}`, true);
          toast(`Error saving item: ${error.message}`, "error");
        }
      }

      function resetGeneratorForm() {
        currentMimeEntries.forEach((entry) => {
          if (entry.previewUrl) {
            URL.revokeObjectURL(entry.previewUrl);
          }
        });

        itemDescriptionInput.value = "";
        mimeEntriesContainer.innerHTML = "";
        currentMimeEntries = [];
        mimeEntryCounter = 0;
        editingItemId = null;
        editingItemIdInput.value = "";
        saveItemButton.textContent = "Save Clipboard Item";
        cancelEditButton.classList.add("hidden");
        updateSaveButtonState();
        setGeneratorStatus("");
        updateGeneratorSummary();
      }

      function loadItemDataIntoGenerator(description, entries, itemIdToEdit) {
        resetGeneratorForm();

        editingItemId = itemIdToEdit;
        editingItemIdInput.value = itemIdToEdit;

        itemDescriptionInput.value = description;

        entries.forEach((entry) => {
          addMimeEntry(entry);
        });

        saveItemButton.textContent = "Save Item";
        cancelEditButton.classList.remove("hidden");
        updateSaveButtonState();
        setGeneratorCollapsed(false);
        generatorSection.scrollIntoView({ behavior: "smooth" });
        setGeneratorStatus(`Editing item: ${description}`, false);
        toast(`Editing “${description}”`, "info");
      }

      function renderSavedItems() {
        savedItemsList.innerHTML = "";

        if (savedClipboardItems.length === 0) {
          savedItemsList.innerHTML =
            '<p class="subtitle">No items saved yet.</p>';
          return;
        }

        savedClipboardItems
          .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
          .forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.classList.add("item");
            itemDiv.dataset.itemId = item.id;

            const contentDiv = document.createElement("div");
            contentDiv.classList.add("item-content");

            const shortDesc =
              item.description.length > 60
                ? item.description.substring(0, 57) + "..."
                : item.description;

            const chipTypes = item.entries
              .map((e) => {
                const label = e.type.split("/")[1] || e.type;
                return `<span class="mime-chip">${label}</span>`;
              })
              .join(" ");

            contentDiv.innerHTML = `${shortDesc} ${chipTypes}`;
            contentDiv.title = item.description;
            itemDiv.appendChild(contentDiv);

            const buttonContainer = document.createElement("div");
            buttonContainer.classList.add("item-buttons");

            const editButton = document.createElement("button");
            editButton.textContent = "Edit";
            editButton.className = "btn secondary";
            editButton.addEventListener("click", () => {
              const itemToEdit = savedClipboardItems.find(
                (i) => i.id === item.id
              );
              if (itemToEdit) {
                loadItemDataIntoGenerator(
                  itemToEdit.description,
                  itemToEdit.entries,
                  item.id
                );
              }
            });
            buttonContainer.appendChild(editButton);

            const copyButton = document.createElement("button");
            copyButton.className = "btn copy";
            copyButton.innerHTML = `<span>Copy</span><span class="check"></span>`;
            copyButton.addEventListener("click", async () => {
              const ok = await copyItemToClipboard(item.id);
              if (ok) {
                copyButton.classList.add("success");
                setTimeout(() => copyButton.classList.remove("success"), 900);
              }
            });
            buttonContainer.appendChild(copyButton);

            const deleteButton = document.createElement("button");
            deleteButton.textContent = "Delete";
            deleteButton.className = "btn danger";
            deleteButton.addEventListener("click", () => {
              animateRemoveItem(itemDiv, () => deleteSavedItem(item.id));
            });
            buttonContainer.appendChild(deleteButton);

            itemDiv.appendChild(buttonContainer);
            savedItemsList.appendChild(itemDiv);
            requestAnimationFrame(() => itemDiv.classList.add("enter"));
          });
      }

      function animateRemoveItem(node, onDone) {
        node.classList.add("exit");
        setTimeout(() => {
          onDone?.();
        }, 240);
      }

      async function deleteSavedItem(itemId) {
        const itemDesc =
          savedClipboardItems.find((i) => i.id === itemId)?.description ||
          "Item";
        savedClipboardItems = savedClipboardItems.filter(
          (item) => item.id !== itemId
        );
        await saveItemsToLocalStorage();
        renderSavedItems();
        setGeneratorStatus(`"${itemDesc}" deleted.`, false);
        toast(`Deleted “${itemDesc}”`, "success");

        if (editingItemId === itemId) {
          resetGeneratorForm();
        }
      }

      async function copyItemToClipboard(itemId) {
        const item = savedClipboardItems.find((i) => i.id === itemId);
        if (!item) {
          setGeneratorStatus("Error: Item not found for copying.", true);
          toast("Item not found for copying.", "error");
          return false;
        }

        if (!navigator.clipboard || !navigator.clipboard.write) {
          setGeneratorStatus(
            "Clipboard API (write) not supported or not available in this context (HTTPS required?).",
            true
          );
          toast(
            "Clipboard write not available. Try HTTPS or a supported browser.",
            "error"
          );
          return false;
        }

        try {
          const clipboardData = {};
          let hasValidData = false;
          for (const entry of item.entries) {
            if (
              (entry.type === "text/plain" || entry.type === "text/html") &&
              typeof entry.data === "string"
            ) {
              clipboardData[entry.type] = new Blob([entry.data], {
                type: entry.type,
              });
              hasValidData = true;
            } else if (entry.type.startsWith("image/") && entry.data instanceof Blob) {
              clipboardData[entry.type] = entry.data;
              hasValidData = true;
            }
          }

          if (!hasValidData) {
            setGeneratorStatus("No valid data found in this item to copy.", true);
            toast("No valid data found in this item to copy.", "error");
            return false;
          }

          const clipboardItem = new ClipboardItem(clipboardData);
          await navigator.clipboard.write([clipboardItem]);
          setGeneratorStatus(`Item "${item.description}" copied to clipboard!`, false);
          toast(`Copied “${item.description}” to clipboard.`, "success");
          return true;
        } catch (error) {
          console.error("Failed to copy item:", error);
          setGeneratorStatus(
            `Error copying to clipboard: ${error.message}. Check permissions/context.`,
            true
          );
          toast(`Copy failed: ${error.message}`, "error");
          return false;
        }
      }

      function setGeneratorStatus(message, isError = false) {
        generatorStatus.textContent = message;
        generatorStatus.className = isError ? "status error" : "status";
      }

      document.addEventListener("paste", async (event) => {
        if (
          !pasteTarget.contains(event.target) &&
          event.target !== pasteTarget &&
          !pasteTarget.matches(":focus-within")
        ) {
          if (!pasteTarget.matches(":focus-within")) return;
        }

        event.preventDefault();
        setWatcherStatus("Processing paste...");
        clearPasteArea();

        const clipboardData = event.clipboardData || window.clipboardData;
        if (!clipboardData) {
          setWatcherStatus("Could not access clipboard data.", true);
          editPastedContentButton.disabled = true;
          toast("Could not access clipboard data.", "error");
          return;
        }

        const types = clipboardData.types;
        if (!types || types.length === 0) {
          setWatcherStatus("No data types found on clipboard.", false);
          editPastedContentButton.disabled = true;
          return;
        }

        let contentRendered = false;
        currentPastedData = [];

        const infoHeader = document.createElement("p");
        infoHeader.innerHTML = `<strong>Detected MIME types:</strong> ${types.join(
          ", "
        )}`;
        pasteTarget.appendChild(infoHeader);
        pasteTarget.appendChild(document.createElement("hr"));

        // Chips for detected types
        detectedChips.innerHTML = "";
        const chipOrder = ["image", "text/html", "text/plain"];
        const toChip = (t) => {
          if (t.startsWith("image/")) return "Image";
          if (t === "text/html") return "HTML";
          if (t === "text/plain") return "Text";
          return t;
        };

        try {
          const imageFiles = Array.from(clipboardData.files).filter((file) =>
            file.type.startsWith("image/")
          );
          if (imageFiles.length > 0) {
            const imageFile = imageFiles[0];
            currentPastedData.push({ type: imageFile.type, data: imageFile });

            const imgElement = document.createElement("img");
            imgElement.alt = "Pasted image";
            pasteTarget.dataset.imageUrl = URL.createObjectURL(imageFile);
            imgElement.src = pasteTarget.dataset.imageUrl;

            const imgHeader = document.createElement("p");
            imgHeader.innerHTML = `<strong>Image Content (${imageFile.type}):</strong>`;
            pasteTarget.appendChild(imgHeader);
            pasteTarget.appendChild(imgElement);
            contentRendered = true;
            setWatcherStatus(`Rendered pasted image (${imageFile.type}).`, false);
            pasteTarget.appendChild(document.createElement("hr"));

            const chip = document.createElement("span");
            chip.className = "chip";
            chip.textContent = "Image";
            detectedChips.appendChild(chip);
          }

          if (types.includes("text/html")) {
            const htmlContent = clipboardData.getData("text/html");
            currentPastedData.push({ type: "text/html", data: htmlContent });

            const htmlContainer = document.createElement("div");
            const header = document.createElement("strong");
            header.textContent = `HTML Content (text/html):`;
            htmlContainer.appendChild(header);
            const toggleId = `toggle-raw-${Date.now()}`;
            const toggleContainer = document.createElement("div");
            toggleContainer.className = "html-toggle-container";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = toggleId;
            const label = document.createElement("label");
            label.htmlFor = toggleId;
            label.textContent = "Show Raw HTML Source";
            toggleContainer.appendChild(checkbox);
            toggleContainer.appendChild(label);
            htmlContainer.appendChild(toggleContainer);
            const renderedDiv = document.createElement("div");
            renderedDiv.className = "html-rendered";
            renderedDiv.innerHTML = htmlContent;
            const rawDiv = document.createElement("div");
            rawDiv.className = "html-raw hidden";
            const pre = document.createElement("pre");
            pre.textContent = htmlContent;
            rawDiv.appendChild(pre);
            checkbox.addEventListener("change", (e) => {
              renderedDiv.classList.toggle("hidden", e.target.checked);
              rawDiv.classList.toggle("hidden", !e.target.checked);
              setPrefs({ htmlShowRaw: e.target.checked });
            });
            // Restore pref
            const prefs = getPrefs();
            if (prefs.htmlShowRaw) {
              checkbox.checked = true;
              renderedDiv.classList.add("hidden");
              rawDiv.classList.remove("hidden");
            }
            htmlContainer.appendChild(renderedDiv);
            htmlContainer.appendChild(rawDiv);
            pasteTarget.appendChild(htmlContainer);
            contentRendered = true;
            pasteTarget.appendChild(document.createElement("hr"));

            const chip = document.createElement("span");
            chip.className = "chip";
            chip.textContent = "HTML";
            detectedChips.appendChild(chip);
          }

          if (types.includes("text/plain")) {
            const textContent = clipboardData.getData("text/plain");

            if (!currentPastedData.some((d) => d.type === "text/html")) {
              currentPastedData.push({ type: "text/plain", data: textContent });
            } else {
              const htmlEntry = currentPastedData.find(
                (d) => d.type === "text/html"
              );
              if (!htmlEntry || htmlEntry.data !== textContent) {
                currentPastedData.push({
                  type: "text/plain",
                  data: textContent,
                });
              }
            }

            const textDiv = document.createElement("div");
            textDiv.innerHTML = `<strong>Plain Text Content (text/plain):</strong><hr>`;
            const pre = document.createElement("pre");
            pre.textContent = textContent;
            textDiv.appendChild(pre);
            pasteTarget.appendChild(textDiv);
            contentRendered = true;

            const chip = document.createElement("span");
            chip.className = "chip";
            chip.textContent = "Text";
            detectedChips.appendChild(chip);
          }

          // Reorder chips in consistent order
          const chipNodes = Array.from(detectedChips.children);
          chipNodes
            .sort((a, b) => {
              const ai = chipOrder.indexOf(
                a.textContent === "Image" ? "image" : a.textContent === "HTML" ? "text/html" : "text/plain"
              );
              const bi = chipOrder.indexOf(
                b.textContent === "Image" ? "image" : b.textContent === "HTML" ? "text/html" : "text/plain"
              );
              return ai - bi;
            })
            .forEach((n) => detectedChips.appendChild(n));

          if (contentRendered) {
            editPastedContentButton.disabled = false;
            if (!getPrefs().generatorCollapsed) {
              // Keep user choice
            } else {
              // Show a helpful toast to open the generator
              toast("Ready to edit? Click “Edit This Content” to open editor.", "info");
            }
          } else {
            setWatcherStatus(
              "Pasted content type(s) not directly renderable or empty.",
              false
            );
            editPastedContentButton.disabled = true;
            currentPastedData = null;
          }
        } catch (error) {
          console.error("Error reading clipboard data:", error);
          setWatcherStatus(`Error processing pasted data: ${error.message}`, true);
          editPastedContentButton.disabled = true;
          currentPastedData = null;
          toast(`Error processing paste: ${error.message}`, "error");
        }
      });

      function clearPasteArea() {
        if (pasteTarget.dataset.imageUrl) {
          URL.revokeObjectURL(pasteTarget.dataset.imageUrl);
          delete pasteTarget.dataset.imageUrl;
        }
        pasteTarget.innerHTML = "";
        detectedChips.innerHTML = "";
        setWatcherStatus("");
        editPastedContentButton.disabled = true;
        currentPastedData = null;
      }

      clearPasteAreaButton.addEventListener("click", clearPasteArea);

      editPastedContentButton.addEventListener("click", () => {
        if (currentPastedData && currentPastedData.length > 0) {
          loadItemDataIntoGenerator(
            "Pasted Content (Edit Me)",
            currentPastedData,
            -1
          );
        } else {
          setWatcherStatus("No content available in the watcher to edit.", true);
          toast("No content available to edit.", "error");
        }
      });

      function setWatcherStatus(message, isError = false) {
        watcherStatus.textContent = message;
        watcherStatus.className = isError ? "status error" : "status";
      }

      function restorePrefs() {
        const prefs = getPrefs();
        setGeneratorCollapsed(!!prefs.generatorCollapsed);
      }

      async function initializeApp() {
        // Collapsible header
        generatorHeader.addEventListener("click", (e) => {
          // Allow clicks on buttons inside to work normally
          if (e.target.closest("button")) return;
          toggleGenerator();
        });

        addMimeButton.addEventListener("click", () => addMimeEntry());
        saveItemButton.addEventListener("click", saveOrUpdateClipboardItem);
        cancelEditButton.addEventListener("click", () => {
          resetGeneratorForm();
          setGeneratorCollapsed(true);
        });
        itemDescriptionInput.addEventListener("input", updateSaveButtonState);

        if (!navigator.clipboard) {
          const apiErrorMsg = "Clipboard API not available (HTTPS may be required).";
          setGeneratorStatus(apiErrorMsg, true);
          setWatcherStatus(apiErrorMsg, true);
          addMimeButton.disabled = true;
          saveItemButton.disabled = true;
          pasteTarget.textContent = "Clipboard API not available.";
          clearPasteAreaButton.disabled = true;
          editPastedContentButton.disabled = true;
          savedItemsList.innerHTML =
            "<p>Cannot load items (Clipboard API unavailable).</p>";
        } else {
          pasteTarget.addEventListener(
            "focus",
            () => (pasteTarget.style.boxShadow = "var(--shadow-focus)")
          );
          pasteTarget.addEventListener(
            "blur",
            () => (pasteTarget.style.boxShadow = "none")
          );

          restorePrefs();
          await loadItemsFromLocalStorage();

          if (!editingItemId) {
            // Start collapsed unless user has a draft (kept false initially)
            if (!getPrefs().generatorCollapsed) {
              setGeneratorCollapsed(false);
            }
          }
        }
      }

      initializeApp();
    </script>
  </body>
</html>
